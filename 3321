-- Carrega biblioteca externa
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()
local Window = Library:NewWindow("Script")
local Tab = Window:NewSection("Credits: TGMANKASKE")

-- Toggle: WalkSpeed infinito
local walkSpeedActive = false
Tab:CreateToggle("Inf WalkSpeed", function(state)
	walkSpeedActive = state

	if walkSpeedActive then
		task.spawn(function()
			while walkSpeedActive do
				local args = {
					"WalkingSpeedGain",
					9999999999
				}
				pcall(function()
					game:GetService("ReplicatedStorage"):WaitForChild("SpeedBoost"):FireServer(unpack(args))
				end)
				task.wait(0.3)
			end
		end)
	end
end)

-- Toggle: Auto Finish com morte ao final
local autoFinishActive = false
local platform = nil

Tab:CreateToggle("Auto Finish", function(state)
	autoFinishActive = state

	if not autoFinishActive then
		if platform and platform.Parent then
			platform:Destroy()
			platform = nil
		end
		return
	end

	local Players = game:GetService("Players")
	local Workspace = game:GetService("Workspace")
	local player = Players.LocalPlayer

	task.spawn(function()
		local character = player.Character or player.CharacterAdded:Wait()
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
		local humanoid = character:FindFirstChildOfClass("Humanoid")

		if not humanoidRootPart or not humanoid then
			warn("Não foi possível encontrar partes do personagem.")
			return
		end

		-- Cria a plataforma se não existir
		if not platform then
			platform = Instance.new("Part")
			platform.Name = "FloatingPlatform"
			platform.Size = Vector3.new(10, 1, 10)
			platform.Anchored = true
			platform.CanCollide = true
			platform.Transparency = 1
			platform.Parent = Workspace
		end

		-- Função: posicionar plataforma abaixo do jogador
		local function positionPlatform()
			if humanoidRootPart and platform then
				platform.CFrame = CFrame.new(humanoidRootPart.Position - Vector3.new(0, 3, 0))
			end
		end

		-- Lista de pontos de teleporte
		local finalPosition = Vector3.new(5732, 1061, 89)
		local teleportPoints = {
			Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("cp2"),
			Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("cp3"),
			Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("cp4"),
			Workspace:FindFirstChild("cp5"),
			Workspace:FindFirstChild("cp6"),
			Workspace:FindFirstChild("cp7"),
			Workspace:FindFirstChild("cp8"),
			Workspace:FindFirstChild("cp9"),
			finalPosition
		}

		-- Execução de teleport
		for _, point in ipairs(teleportPoints) do
			if not autoFinishActive then break end

			local targetPos = typeof(point) == "Instance" and point.Position or point
			humanoidRootPart.CFrame = CFrame.new(targetPos)
			positionPlatform()

			print("Teleportado para:", targetPos)
			task.wait(1)

			-- Se for o último ponto, mata o jogador
			if typeof(point) ~= "Instance" and point == finalPosition then
				if platform then
					platform:Destroy()
					platform = nil
				end
				if humanoid then
					humanoid.Health = 0
					print("Morte após último teleport.")
				end
				break
			end
		end

		autoFinishActive = false
	end)
end)
